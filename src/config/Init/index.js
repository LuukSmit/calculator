/* eslint-disable no-restricted-syntax */
/* eslint-disable import/no-extraneous-dependencies */
/* eslint-disable no-nested-ternary */
const fs = require('fs');
const recursive = require('recursive-readdir');
const path = require('path');
const jsdoc2md = require('jsdoc-to-markdown');
const glob = require('glob');
const icons = require('../FontAwesome/fontawesome.json');

const { name } = require('../../../package.json');

const { platform } = process;
const slash = platform === 'win32' ? '\\' : '/';

const rootFolder = 'src';

const allFilePromises = [];
const types = ['components', 'views', 'config', 'custom'];

let components = [];
const customComponents = [];
const customStylesheets = [];
const stylesheets = [
  { type: 'Fonts', name: './fonts' },
  { type: 'Base', name: './responsive' },
  { type: 'Base', name: './settings' },
  { type: 'Base', name: './toast' },
  { type: 'Base', name: './base' },
  { type: 'Base', name: './ie' },
  { type: 'Custom', name: './custom' },
];


const exceptions = ['C4', 'i18n', 'locales', 'init'];
const manualItems = [
  { component: 'locales', path: 'config/i18n' },
  { component: 'AppRouter', path: 'routers/AppRouter' },
  { component: 'SubRouter', path: 'routers/SubRouter' },
  { component: 'ScrollToTop', path: 'routers/ScrollToTop' },
];

const autoWarning = '/* THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. */';

const alphabetSort = ({ path: pathA }, { path: pathB }) => ((pathA < pathB) ? -1 : (pathA > pathB) ? 1 : 0);

const read = directory => new Promise((resolve, reject) => {
  if (!fs.existsSync(directory)) fs.mkdirSync(directory, { recursive: true });
  recursive(directory, (err, folders) => {
    if (err) {
      const customError = err;
      /* .replace(/\\+/g, '/') */
      return reject(customError);
    } return resolve({
      folders: [
        ...new Set(folders
          .map(folder => folder
            .replace(/(.*?)custom./, '')
            .substring(0, folder
              .replace(/(.*?)custom./, '')
              .lastIndexOf(slash)))),
      ],
      pathToDir: directory,
    });
  });
});

const checkCustom = () => new Promise((resolve) => {
  read(path.resolve(rootFolder, 'custom'))
    .then((res) => {
      [...new Set(res.folders)].forEach((folder) => {
        const dir = fs.readdirSync(`${res.pathToDir}${slash}${folder}`);
        const [stylesheet] = dir.filter(val => val.slice(-5) === '.scss');
        const [component] = dir.filter(val => `${folder}.js`.includes(val));

        if (stylesheet && stylesheet.length > 0) {
          customStylesheets.push(stylesheet.substring(1, stylesheet.indexOf('.scss')));
        }
        if (component && component.length > 0) {
          customComponents.push(component.substring(0, component.indexOf('.js')));
        }
      });
      resolve({ status: 'custom found' });
    })
    .catch(({ code }) => {
      if (code === 'ENOENT') {
        resolve({ status: 'custom not found' });
      }
    });
});

const checkFolder = (pathToDir, type) => {
  if (fs.lstatSync(pathToDir).isDirectory()) {
    const folderContents = fs.readdirSync(pathToDir);

    const cleanedContent = folderContents.filter((contents) => {
      const isDir = fs.lstatSync(path.resolve(pathToDir, contents)).isDirectory();
      const isScss = (contents.slice(-5) === '.scss' || contents.slice(-5) === '.sass');
      const isJson = contents.slice(-5) === '.json';
      const isIndex = contents === 'index.js';
      const isMdx = contents.slice(-3) === '.md';

      if (isScss) {
        stylesheets.push({
          component: `${contents.substring(1, contents.indexOf('.scss'))}`,
          path: pathToDir.substring(pathToDir.indexOf(type)),
          type,
        });
      }
      return (!isDir && !isScss && !isJson && !isIndex && !isMdx);
    });
    cleanedContent.forEach((file) => {
      const component = file.substring(0, file.indexOf('.js'));
      components.push({ component, path: pathToDir.substring(pathToDir.indexOf(type)) });
    });
    folderContents.forEach((subElement) => {
      const isDir = fs.lstatSync(path.resolve(pathToDir, subElement)).isDirectory();
      if (isDir) {
        checkFolder(path.resolve(pathToDir, subElement), type);
      }
    });
  }
};

const getAll = type => new Promise((resolve) => {
  read(path.resolve(rootFolder, type))
    .then((dir) => {
      const { folders, pathToDir } = dir;
      components = [];
      folders.forEach((folder) => {
        if (!exceptions.includes(folder)) {
          checkFolder(path.resolve(pathToDir, folder), type);
        }
      });
      resolve(components);
    })
    .catch(console.error);
});

const writeJsFile = (originalComponents) => {
  let jsFile = `${autoWarning}\n\n`;
  const componentLists = originalComponents;
  componentLists.push(manualItems);
  types.push('manual');
  componentLists.forEach((list, i) => {
    console.info(`Writing: ${types[i]}.`);
    jsFile += `// ${types[i][0].toUpperCase()}${types[i].substring(1)}\n`;

    [...new Set(list
      .map(item => JSON.stringify(item)))]
      .map(item => JSON.parse(item))
      .filter(({ path: p }) => !['locales'].some(e => p.endsWith(e)))
      .sort(alphabetSort)
      .filter(({ component: item }) => {
        if (types[i] === 'custom') {
          return !originalComponents.slice(0, originalComponents.length - 2).flat().map(({ component }) => component).includes(item);
        } return true;
      })
      .forEach(({ component, path: componentPath }) => {
        if (component.length > 0 && customComponents.includes(component)) {
          jsFile += `export { default as ${component} } from '${componentPath.replace(types[i], 'custom').replace(/\\/g, '/')}';\n`;
        } else if (component.length > 0) jsFile += `export { default as ${component} } from '${componentPath.replace(/\\/g, '/')}';\n`;
      });
    jsFile += '\n';
  });
  jsFile += `\n${autoWarning}`;
  return jsFile;
};

const writeStylesFile = () => {
  let stylesFile = `${autoWarning}\n\n`;
  types.unshift('Fonts', 'Base');
  types.push('Custom');

  types.forEach((list, i) => {
    console.info(`Writing: ${types[i]} stylesheets.`);
    const typeList = [...new Set(stylesheets
      .filter(item => item.type === types[i])
      .filter(({ component: item }) => {
        if (types[i] === 'custom') {
          return !stylesheets.filter(({ type }) => type === types[i]).map(({ component }) => component).includes(item);
        }
        return true;
      })
      .map(item => JSON.stringify(item)))].map(item => JSON.parse(item));

    if (typeList.length > 0) {
      stylesFile += `// ${types[i][0].toUpperCase()}${types[i].substring(1)}\n`;
      typeList.sort(alphabetSort).forEach(({ component, path: componentPath, name: n }) => {
        if (component && componentPath) {
          if (customStylesheets.includes(component)) {
            stylesFile += `@import '../../${componentPath.replace(types[i], 'custom').replace(/\\/g, '/')}/${component}';\n`;
          } else stylesFile += `@import '../../${componentPath.replace(/\\/g, '/')}/${component}';\n`;
        } else stylesFile += `@import '${n}';\n`;
      });
    }
    stylesFile += '\n';
  });
  stylesFile += `\n${autoWarning}`;
  return stylesFile;
};

const writeFontAwesomeFile = () => {
  let iconsFile = `${autoWarning}\n\n`;
  iconsFile += 'import { library } from \'@fortawesome/fontawesome-svg-core\';\n\n';
  const packages = {
    fab: 'brands',
    fal: 'light',
    far: 'regular',
    fas: 'solid',
  };
  const exportObject = [];
  Object.keys(icons).forEach((key) => {
    const names = icons[key]
      .map(iconName => iconName.split('-'))
      .map(iconName => iconName.map(n => `${n[0].toUpperCase()}${n.slice(1)}`).join(''));

    if ([...new Set(names)].length !== icons[key].length) console.warn('Duplicate values in fontawesome.json');

    iconsFile += `// ${packages[key][0].toUpperCase()}${packages[key].slice(1)}\n`;
    [...new Set(names)].forEach((iconName) => {
      const iconPath = `@fortawesome/${key === 'fab' ? 'free' : 'pro'}-${packages[key]}-svg-icons/fa${iconName}`;
      iconsFile += `import { fa${iconName} as ${key}${iconName} } from '${iconPath}';\n`;
      exportObject.push(`${key}${iconName}`);
    });
    iconsFile += '\n';
  });

  iconsFile += `const exports = {\n${exportObject.map(o => `  ${o}`).join(',\n')},\n};\n\n`;
  iconsFile += `export default library.add(...Object.values(exports));\n\n${autoWarning}`;
  return iconsFile;
};

const writeMarkdownFiles = async () => {
  glob(`${path.resolve(path.resolve('src/config/!(C4|FontAwesome)*/+([A-Z])*.js'))}`, (err, files) => {
    files.forEach((file) => {
      const input = file;
      const output = file.substring(0, file.lastIndexOf('/') + 1);
      const fileName = file.substring(file.lastIndexOf('/') + 1, file.lastIndexOf('.'));

      glob(`${path.resolve('src/styleguide/partials/*.hbs')}`, (err2, partial) => {
        const templateData = jsdoc2md.getTemplateDataSync({ files: input })
          .map((item) => {
            const object = item;
            ['scope', 'kind'].forEach(key => delete object[key]);
            return object;
          });

        const outputString = jsdoc2md.renderSync({
          data: templateData,
          partial,
          'heading-depth': 3,
          separators: true,
        });

        fs.writeFileSync(path.resolve(output, `${fileName}.md`), outputString);
      });
    });
  });
};

checkCustom()
  .then(() => {
    types.forEach((folder) => {
      allFilePromises.push(getAll(folder));
    });

    Promise.all(allFilePromises)
      .then((componentLists) => {
        const jsFile = writeJsFile(componentLists);
        const stylesFile = writeStylesFile();
        const iconsFile = writeFontAwesomeFile();
        if (name === 'template') {
          writeMarkdownFiles();
        }

        fs.mkdir(path.resolve(rootFolder, `config${slash}C4`), { recursive: true }, () => {
          fs.writeFile(`${path.resolve(rootFolder, `config${slash}C4`)}${slash}index.js`, jsFile, () => {
            console.info('\nFinished writing C4 file.');
          });
        });
        fs.writeFile(`${path.resolve(rootFolder, `assets${slash}styles`)}${slash}styles.scss`, stylesFile, () => {
          console.info('\nFinished writing styles file.');
        });
        fs.writeFile(`${path.resolve(rootFolder, `config${slash}FontAwesome`)}${slash}FontAwesome.js`, iconsFile, () => {
          console.info('\nFinished writing FontAwesome file.');
        });
      });
  });
